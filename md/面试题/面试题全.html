<!DOCTYPE html>
<html lang="zh-CN">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>答案 | Java 全栈知识体系</title>
    <meta name="description" content="包含: Java 基础, Java 部分源码, JVM, Spring, Spring Boot, Spring Cloud, 数据库原理, MySQL, ElasticSearch, MongoDB, Docker, k8s, CI&amp;CD, Linux, DevOps, 分布式, 中间件, 开发工具, Git, IDE, 源码阅读，读书笔记, 开源项目...">
    <link rel="icon" href="/person-log.io/images/photo.jpg">
  <link rel="manifest" href="/person-log.io/images/photo.jpg">
  <link rel="apple-touch-icon" href="/person-log.io/images/photo.jpg">
  <meta http-quiv="pragma" cotent="no-cache">
  <meta http-quiv="pragma" cotent="no-cache,must-revalidate">
  <meta http-quiv="expires" cotent="0">
    
    <link rel="preload" href="/person-log.io/assets/css/0.styles.4ff3082f.css" as="style"><link rel="preload" href="/person-log.io/assets/js/app.900e0138.js" as="script"><link rel="preload" href="/person-log.io/assets/js/22.eb619a13.js" as="script"><link rel="prefetch" href="/person-log.io/assets/js/10.5d3102c6.js"><link rel="prefetch" href="/person-log.io/assets/js/100.8abb6c0d.js"><link rel="prefetch" href="/person-log.io/assets/js/101.e70ee001.js"><link rel="prefetch" href="/person-log.io/assets/js/102.8eb6e9a9.js"><link rel="prefetch" href="/person-log.io/assets/js/103.4868ab00.js"><link rel="prefetch" href="/person-log.io/assets/js/104.1f3ae061.js"><link rel="prefetch" href="/person-log.io/assets/js/105.b4d44644.js"><link rel="prefetch" href="/person-log.io/assets/js/106.ed41d71f.js"><link rel="prefetch" href="/person-log.io/assets/js/107.99d8e0f9.js"><link rel="prefetch" href="/person-log.io/assets/js/108.b8cdbf75.js"><link rel="prefetch" href="/person-log.io/assets/js/109.e598b3d2.js"><link rel="prefetch" href="/person-log.io/assets/js/11.dd8a8a0d.js"><link rel="prefetch" href="/person-log.io/assets/js/110.45af1b3c.js"><link rel="prefetch" href="/person-log.io/assets/js/111.62ae94fd.js"><link rel="prefetch" href="/person-log.io/assets/js/112.b9434dad.js"><link rel="prefetch" href="/person-log.io/assets/js/113.377bbf43.js"><link rel="prefetch" href="/person-log.io/assets/js/114.5a6b7bd8.js"><link rel="prefetch" href="/person-log.io/assets/js/115.103372d3.js"><link rel="prefetch" href="/person-log.io/assets/js/116.43e77bfc.js"><link rel="prefetch" href="/person-log.io/assets/js/117.fc88e5e3.js"><link rel="prefetch" href="/person-log.io/assets/js/118.a169c7d0.js"><link rel="prefetch" href="/person-log.io/assets/js/119.4434297d.js"><link rel="prefetch" href="/person-log.io/assets/js/12.f6fdf928.js"><link rel="prefetch" href="/person-log.io/assets/js/120.ae5585ff.js"><link rel="prefetch" href="/person-log.io/assets/js/121.b7238501.js"><link rel="prefetch" href="/person-log.io/assets/js/122.3aa0028c.js"><link rel="prefetch" href="/person-log.io/assets/js/123.889610c6.js"><link rel="prefetch" href="/person-log.io/assets/js/124.2d9a318a.js"><link rel="prefetch" href="/person-log.io/assets/js/125.72b2c2f7.js"><link rel="prefetch" href="/person-log.io/assets/js/126.bd4ce6c8.js"><link rel="prefetch" href="/person-log.io/assets/js/13.5710e644.js"><link rel="prefetch" href="/person-log.io/assets/js/14.dd6c1cd0.js"><link rel="prefetch" href="/person-log.io/assets/js/15.7149798f.js"><link rel="prefetch" href="/person-log.io/assets/js/16.7bd52a2f.js"><link rel="prefetch" href="/person-log.io/assets/js/17.4daa4746.js"><link rel="prefetch" href="/person-log.io/assets/js/18.d4bdd6a7.js"><link rel="prefetch" href="/person-log.io/assets/js/19.95ddf026.js"><link rel="prefetch" href="/person-log.io/assets/js/2.143de871.js"><link rel="prefetch" href="/person-log.io/assets/js/20.615f1176.js"><link rel="prefetch" href="/person-log.io/assets/js/21.9d613190.js"><link rel="prefetch" href="/person-log.io/assets/js/23.70512efd.js"><link rel="prefetch" href="/person-log.io/assets/js/24.a299e3cc.js"><link rel="prefetch" href="/person-log.io/assets/js/25.e0bc91d9.js"><link rel="prefetch" href="/person-log.io/assets/js/26.bdd22671.js"><link rel="prefetch" href="/person-log.io/assets/js/27.6b7b12a6.js"><link rel="prefetch" href="/person-log.io/assets/js/28.d3ee9e71.js"><link rel="prefetch" href="/person-log.io/assets/js/29.3846b469.js"><link rel="prefetch" href="/person-log.io/assets/js/3.cd8ff11a.js"><link rel="prefetch" href="/person-log.io/assets/js/30.06463218.js"><link rel="prefetch" href="/person-log.io/assets/js/31.c52bcd52.js"><link rel="prefetch" href="/person-log.io/assets/js/32.aeb3a009.js"><link rel="prefetch" href="/person-log.io/assets/js/33.e9ece8bf.js"><link rel="prefetch" href="/person-log.io/assets/js/34.aa658d65.js"><link rel="prefetch" href="/person-log.io/assets/js/35.b0e6429a.js"><link rel="prefetch" href="/person-log.io/assets/js/36.11c95fd3.js"><link rel="prefetch" href="/person-log.io/assets/js/37.f6b7ce7c.js"><link rel="prefetch" href="/person-log.io/assets/js/38.2c0daf10.js"><link rel="prefetch" href="/person-log.io/assets/js/39.a2359299.js"><link rel="prefetch" href="/person-log.io/assets/js/4.f87d085e.js"><link rel="prefetch" href="/person-log.io/assets/js/40.67e9271b.js"><link rel="prefetch" href="/person-log.io/assets/js/41.b530b7d7.js"><link rel="prefetch" href="/person-log.io/assets/js/42.ceec96ec.js"><link rel="prefetch" href="/person-log.io/assets/js/43.1882528a.js"><link rel="prefetch" href="/person-log.io/assets/js/44.9c4e1af8.js"><link rel="prefetch" href="/person-log.io/assets/js/45.4ddef8e4.js"><link rel="prefetch" href="/person-log.io/assets/js/46.67313dc2.js"><link rel="prefetch" href="/person-log.io/assets/js/47.5c6b2c29.js"><link rel="prefetch" href="/person-log.io/assets/js/48.b7e57021.js"><link rel="prefetch" href="/person-log.io/assets/js/49.bff0de67.js"><link rel="prefetch" href="/person-log.io/assets/js/5.13ef03c9.js"><link rel="prefetch" href="/person-log.io/assets/js/50.0570550e.js"><link rel="prefetch" href="/person-log.io/assets/js/51.7e536feb.js"><link rel="prefetch" href="/person-log.io/assets/js/52.a011b658.js"><link rel="prefetch" href="/person-log.io/assets/js/53.c8ba3843.js"><link rel="prefetch" href="/person-log.io/assets/js/54.7ec121d9.js"><link rel="prefetch" href="/person-log.io/assets/js/55.516a38ec.js"><link rel="prefetch" href="/person-log.io/assets/js/56.62b2636e.js"><link rel="prefetch" href="/person-log.io/assets/js/57.b3111d41.js"><link rel="prefetch" href="/person-log.io/assets/js/58.4e4428b3.js"><link rel="prefetch" href="/person-log.io/assets/js/59.4bd160cb.js"><link rel="prefetch" href="/person-log.io/assets/js/6.246d68f0.js"><link rel="prefetch" href="/person-log.io/assets/js/60.147eae57.js"><link rel="prefetch" href="/person-log.io/assets/js/61.ece9faa7.js"><link rel="prefetch" href="/person-log.io/assets/js/62.42d5a03e.js"><link rel="prefetch" href="/person-log.io/assets/js/63.618c9a42.js"><link rel="prefetch" href="/person-log.io/assets/js/64.4a5e7887.js"><link rel="prefetch" href="/person-log.io/assets/js/65.e7fb9653.js"><link rel="prefetch" href="/person-log.io/assets/js/66.29e33acf.js"><link rel="prefetch" href="/person-log.io/assets/js/67.ce40420e.js"><link rel="prefetch" href="/person-log.io/assets/js/68.9ae9da96.js"><link rel="prefetch" href="/person-log.io/assets/js/69.798d9970.js"><link rel="prefetch" href="/person-log.io/assets/js/7.77d79df0.js"><link rel="prefetch" href="/person-log.io/assets/js/70.5ebe26ce.js"><link rel="prefetch" href="/person-log.io/assets/js/71.79a27be8.js"><link rel="prefetch" href="/person-log.io/assets/js/72.a4c84ae1.js"><link rel="prefetch" href="/person-log.io/assets/js/73.be2bf486.js"><link rel="prefetch" href="/person-log.io/assets/js/74.2e32e870.js"><link rel="prefetch" href="/person-log.io/assets/js/75.fbabbd25.js"><link rel="prefetch" href="/person-log.io/assets/js/76.ea1ba140.js"><link rel="prefetch" href="/person-log.io/assets/js/77.4ce215b3.js"><link rel="prefetch" href="/person-log.io/assets/js/78.4757c020.js"><link rel="prefetch" href="/person-log.io/assets/js/79.398d6895.js"><link rel="prefetch" href="/person-log.io/assets/js/8.f33fb86b.js"><link rel="prefetch" href="/person-log.io/assets/js/80.2913d38e.js"><link rel="prefetch" href="/person-log.io/assets/js/81.00d718fe.js"><link rel="prefetch" href="/person-log.io/assets/js/82.49baf639.js"><link rel="prefetch" href="/person-log.io/assets/js/83.0b255dec.js"><link rel="prefetch" href="/person-log.io/assets/js/84.aa39b1b8.js"><link rel="prefetch" href="/person-log.io/assets/js/85.220a5565.js"><link rel="prefetch" href="/person-log.io/assets/js/86.5381f000.js"><link rel="prefetch" href="/person-log.io/assets/js/87.55b5c1f1.js"><link rel="prefetch" href="/person-log.io/assets/js/88.f9d2f70c.js"><link rel="prefetch" href="/person-log.io/assets/js/89.d9463204.js"><link rel="prefetch" href="/person-log.io/assets/js/9.6dba6746.js"><link rel="prefetch" href="/person-log.io/assets/js/90.6b0a709d.js"><link rel="prefetch" href="/person-log.io/assets/js/91.4ae96144.js"><link rel="prefetch" href="/person-log.io/assets/js/92.b9357539.js"><link rel="prefetch" href="/person-log.io/assets/js/93.59c128af.js"><link rel="prefetch" href="/person-log.io/assets/js/94.1008960c.js"><link rel="prefetch" href="/person-log.io/assets/js/95.128fb549.js"><link rel="prefetch" href="/person-log.io/assets/js/96.d74f8117.js"><link rel="prefetch" href="/person-log.io/assets/js/97.afeacc56.js"><link rel="prefetch" href="/person-log.io/assets/js/98.4de04002.js"><link rel="prefetch" href="/person-log.io/assets/js/99.599f733a.js">
    <link rel="stylesheet" href="/person-log.io/assets/css/0.styles.4ff3082f.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/person-log.io/" class="home-link router-link-active"><!----> <span class="site-name">Java 全栈知识体系</span></a> <div class="links" style="max-width:nullpx;"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/person-log.io/md/" class="nav-link router-link-active">导读</a></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title">Java</span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/person-log.io/md/JAVA/" class="nav-link">JAVA基础</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title">数据库</span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/person-log.io/md/database/base/" class="nav-link">数据库基础</a></li><li class="dropdown-item"><!----> <a href="/person-log.io/md/database/Mysql/" class="nav-link">MySQL</a></li><li class="dropdown-item"><!----> <a href="/person-log.io/md/database/Redis/" class="nav-link">Redis</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title">计算机网络</span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/person-log.io/md/计算机网络/图解网络.html" class="nav-link">图解网络</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title">项目部署</span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/person-log.io/md/DevOps/Docker/" class="nav-link">Docker</a></li><li class="dropdown-item"><!----> <a href="/person-log.io/md/DevOps/jenkins/" class="nav-link">jenkins</a></li><li class="dropdown-item"><!----> <a href="/person-log.io/md/DevOps/consul-cluster/" class="nav-link">consul</a></li><li class="dropdown-item"><!----> <a href="/person-log.io/md/DevOps/Nginx/" class="nav-link">Nginx</a></li><li class="dropdown-item"><!----> <a href="/person-log.io/md/DevOps/Linux/" class="nav-link">Linux</a></li><li class="dropdown-item"><!----> <a href="/person-log.io/md/DevOps/blog/" class="nav-link">个人博客</a></li></ul></div></div> <a href="https://github.com/caizongkai/vuepressDemo" target="_blank" rel="noopener noreferrer" class="repo-link">
    修改文档
    <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></nav></div></header> <div class="sidebar-mask"></div> <div class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/person-log.io/md/" class="nav-link router-link-active">导读</a></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title">Java</span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/person-log.io/md/JAVA/" class="nav-link">JAVA基础</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title">数据库</span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/person-log.io/md/database/base/" class="nav-link">数据库基础</a></li><li class="dropdown-item"><!----> <a href="/person-log.io/md/database/Mysql/" class="nav-link">MySQL</a></li><li class="dropdown-item"><!----> <a href="/person-log.io/md/database/Redis/" class="nav-link">Redis</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title">计算机网络</span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/person-log.io/md/计算机网络/图解网络.html" class="nav-link">图解网络</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title">项目部署</span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/person-log.io/md/DevOps/Docker/" class="nav-link">Docker</a></li><li class="dropdown-item"><!----> <a href="/person-log.io/md/DevOps/jenkins/" class="nav-link">jenkins</a></li><li class="dropdown-item"><!----> <a href="/person-log.io/md/DevOps/consul-cluster/" class="nav-link">consul</a></li><li class="dropdown-item"><!----> <a href="/person-log.io/md/DevOps/Nginx/" class="nav-link">Nginx</a></li><li class="dropdown-item"><!----> <a href="/person-log.io/md/DevOps/Linux/" class="nav-link">Linux</a></li><li class="dropdown-item"><!----> <a href="/person-log.io/md/DevOps/blog/" class="nav-link">个人博客</a></li></ul></div></div> <a href="https://github.com/caizongkai/vuepressDemo" target="_blank" rel="noopener noreferrer" class="repo-link">
    修改文档
    <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></nav>  <ul class="sidebar-links"><li><div class="sidebar-group first"><p class="sidebar-heading open"><span>导航</span> <!----></p> <ul class="sidebar-group-items"><li><a href="/person-log.io/md/JAVA/" class="sidebar-link">JAVA</a></li><li><a href="/person-log.io/md/DevOps/" class="sidebar-link">项目部署</a></li></ul></div></li></ul> </div> <div class="page"> <div class="content"><h1 id="答案"><a href="#答案" class="header-anchor">#</a> 答案</h1> <h2 id="java基础"><a href="#java基础" class="header-anchor">#</a> JAVA基础</h2> <ul><li><p><strong>String为什么是不可变的？不可变的好处</strong></p> <p>String的value被final修饰，String不可变的好处有下面几点：</p> <ol><li>可以缓存 hash 值，因为 String 的 hash 值经常被使用，例如 String 用做 HashMap 的 key。不可变的特性可以使得 hash 值也不可变，因此只需要进行一次计算。</li> <li>String Pool 的需要，如果一个 String 对象已经被创建过了，那么就会从 String Pool 中取得引用。只有 String 是不可变的，才可能使用 String Pool。</li> <li>安全性，String 经常作为参数，String 不可变性可以保证参数不可变。例如在作为网络连接参数的情况下如果 String 是可变的，那么在网络连接过程中，String 被改变，改变 String 对象的那一方以为现在连接的是其它主机，而实际情况却不一定是。</li> <li>线程安全，String 不可变性天生具备线程安全，可以在多个线程中安全地使用。</li></ol></li></ul> <h2 id="集合"><a href="#集合" class="header-anchor">#</a> 集合</h2> <ul><li><p><strong>ArrayList 和 Vector 的区别。</strong></p> <p>1、Vector是线程安全的，ArrayList不是线程安全的。
2、ArrayList在底层数组不够用时在原来的基础上扩展0.5倍，Vector是扩展1倍。</p></li> <li><p>快速失败 (fail-fast) 和安全失败 (fail-safe) 的区别是什么？</p> <p>在用迭代器（Iterator it = list.iterator();）遍历一个集合对象时，是直接对原集合进行遍历，如果遍历过程中对集合对象的内容进行了修改（增加、删除、修改），则会抛出Concurrent Modification Exception。迭代器在遍历时直接访问集合中的内容，并且在遍历过程中使用一个 modCount 变量。集合在被遍历期间如果内容发生变化，就会改变modCount的值。每当迭代器使用hashNext()/next()遍历下一个元素之前，都会检测modCount变量是否为expectedmodCount值，是的话就返回遍历；否则抛出异常，终止遍历。
安全失败，由于迭代时是对原集合的拷贝进行遍历，所以在遍历过程中对原集合所作的修改并不能被迭代器检测到，所以不会触发Concurrent Modification Exception。</p></li> <li><p><strong>HashMap 的工作原理是什么?</strong>（会让讲讲个别api的流程，如get，put）</p> <p>put方法是先计算key的hashcode，然后进行高低位异或运算计算出hash值，再跟数组的长度-1进行与运算，得出所在的hash桶，如果该hash桶为空，则直接插入，否则判断是否有相同的key，如果有直接覆盖插入，如果没有，则判断当前数据结构是红黑树还是链表，如果是红黑树直接插入，如果是链表则判断链表长度插入后是否大于等于8，如果大于等于8，则转换为红黑树插入，否则直接插入。
get方法就是计算出要获取元素的hash值，去对应位置取即可。</p> <p>扩容机制，hashmap的扩容中主要进行两步，第一步把数组长度变为原来的两倍，第二部把旧数组的元素重新计算存储位置然后插入新数组中。</p></li> <li><p><strong>Hashmap 什么时候进行扩容呢？</strong></p> <p>当元素长度大于数组长度（默认16）* 负载因子（默认0.75）时。</p></li> <li><p>HashSet 和 TreeSet 有什么区别？</p> <p>HashSet是通过HashMap实现的,TreeSet是通过TreeMap实现的</p> <p>TreeMap更是多了一个排序的功能</p></li> <li><p>LinkedHashMap 的实现原理? （没被问到过）</p></li> <li><p><strong>什么是迭代器 (Iterator)？</strong></p> <p>迭代器是一种设计模式，Collection接口继承了迭代器接口，子类可以用iterator()方法产生一个迭代器，可以对集合进行迭代。</p></li> <li><p><strong>Iterator 和 ListIterator 的区别是什么？</strong></p> <p>1、Iterator可用来遍历Set和List集合，但是ListIterator只能用来遍历List。</p> <p>2、Iterator对集合只能是前向遍历，ListIterator既可以前向也可以后向。</p></li> <li><p><strong>数组 (Array) 和列表 (ArrayList) 有什么区别？什么时候应该使用 Array 而不是 ArrayList？</strong></p> <p>Array 可以包含基本类型和对象类型，ArrayList 只能包含对象类型。</p> <p>Array 大小是固定的，ArrayList 的大小是动态变化的。</p> <p>当处理固定大小的基本数据类型的时候，使用Array。</p></li> <li><p><strong>ArrayList和LinkedList有何区别？</strong></p> <p>1、ArrayList基于数组，LinkedList基于链表</p> <p>2、ArrayList查找快，LinkedList增删快</p></li> <li><p>Comparable 和 Comparator 接口是干什么的？列出它们的区别。</p></li> <li><p>Collection 和 Collections 的区别。</p></li> <li><p>Java集合框架的基础接口有哪些？</p></li> <li><p><strong>我们能否使用任何类作为Map的key？</strong></p> <p>1、要手动实现equals和hashcode()方法,并且符合hashcode和equals的相关规则</p> <p>2、最好是不可变类，可以缓存hash值</p></li> <li><p><strong><font color="red">HashMap为什么不直接使用hashCode()处理后的哈希值直接作为table的下标？</font></strong></p> <p>两次扰动可以减少哈希碰撞</p></li> <li><p><strong><font color="red">为什么数组长度要保证为2的幂次方呢</font>？</strong> 这两个都是为了扰动</p> <p>只有数组长度为2的幂次方时，才能用与运算代替取模运算，增快效率</p> <p>减少哈希碰撞，减少空间浪费</p> <p>扩容时如果是2的幂次方，方便计算位置，不用重新去根据hash值和数组长度去计算，直接判断数组长度新增的那一位的hash值是0还是1，如果是0，则位置不变，如果是1，则位置是当前位置+原数组长度。</p></li> <li><p><strong>ConcurrentHashMap的具体实现知道吗？</strong></p> <p>采用Node + CAS + Synchronized来保证并发安全进行实现，如果Node为空，则用CAS插入数据，如果不为空，则对Node加synchronized锁</p></li> <li><p><strong>HashMap的扩容操作是怎么实现的？</strong></p> <p>1.首先进行异常情况的判断，如是否需要初始化，二是若当前容量最大值则不扩容</p> <p>2.然后根据新容量(是就容量的2倍)新建数组，将旧数组上的数据(键值对)转移到新的数组中，这里包括：(遍历旧数组的每个元素，重新计算每个数据在数组中的存放位置。(原位置或者原位置+旧容量)，将旧数组上的每个数据逐个转移到新数组中，这里采用的是尾插法。)</p> <p>3.新数组table引用到HashMap的table属性上</p> <p>4.最后重新设置扩容阈值。</p></li></ul> <h2 id="并发"><a href="#并发" class="header-anchor">#</a> 并发</h2> <ul><li><p><strong>那么请谈谈 AQS 框架是怎么回事儿？</strong></p> <p>AQS（AbstractQueuedSynchronizer 类）是一个用来构建锁和同步器的框架，各种 Lock 包中的锁（常用的有 ReentrantLock、ReadWriteLock），以及其他如 Semaphore、CountDownLatch，甚至是早期的 FutureTask 等，都是基于 AQS 来构建。</p> <p>1.AQS 在内部定义了一个 volatile int state 变量，表示同步状态：当线程调用 lock 方法时 ，如果 state=0，说明没有任何线程占有共享资源的锁，可以获得锁并将 state=1；如果 state=1，则说明有线程目前正在使用共享变量，其他线程必须加入同步队列进行等待。</p> <p>2.AQS 通过 Node 内部类构成的一个双向链表结构的同步队列，来完成线程获取锁的排队工作，当有线程获取锁失败后，就被添加到队列末尾。Node 类是对要访问同步代码的线程的封装，包含了线程本身及其状态叫 waitStatus（有五种不同 取值，分别表示是否被阻塞，是否等待唤醒，是否已经被取消等），每个 Node 结点关联其 prev 结点和 next 结点，方便线程释放锁后快速唤醒下一个在等待的线程，是一个 FIFO 的过程。</p> <p>Node 类有两个常量，SHARED 和 EXCLUSIVE，分别代表共享模式和独占模式。所谓共享模式是一个锁允许多条线程同时操作（信号量 Semaphore 就是基于 AQS 的共享模式实现的），独占模式是同一个时间段只能有一个线程对共享资源进行操作，多余的请求线程需要排队等待（如 ReentranLock）。</p> <p>3.AQS 通过内部类 ConditionObject 构建等待队列（可有多个），当 Condition 调用 wait() 方法后，线程将会加入等待队列中，而当 Condition 调用 signal() 方法后，线程将从等待队列转移动同步队列中进行锁竞争。</p> <p>4.AQS 和 Condition 各自维护了不同的队列，在使用 Lock 和 Condition 的时候，其实就是两个队列的互相移动。</p></li> <li><p><strong>请尽可能详尽地对比下 Synchronized 和 ReentrantLock 的异同。</strong></p> <p>一个是关键字，一个是类</p> <p>lock可以实现精准通知，synchronized不行</p> <p>Lock要手动释放锁</p> <p>Lock可以判断锁的状态</p> <p>Lock可以尝试获取锁</p> <p>Lock可以中断锁</p> <p>Lock可以是公平的也可以是非公平的</p></li> <li><p><strong>ReentrantLock 是如何实现可重入性的？</strong></p> <p>ReentrantLock 内 部 自 定 义 了 同 步 器 Sync（ Sync 既实现了 AQS， 又实现了 AOS， 而 AOS提 供 了 一 种 互 斥 锁 持 有 的 方 式 ） ， 其实就是加锁的 时 候 通 过 CAS 算法， 将线程对象放到一个双向链表中， 每次获取 锁 的时 候 ， 看 下 当 前 维 护 的 那 个 线 程 ID 和 当 前 请 求 的 线 程 ID 是 否一 样 ，一样就可重入了。</p></li> <li><p><strong>说说线程池的工作流程</strong></p></li> <li><p><strong>Java 中的线程池是如何实现的？</strong></p> <p>在 Java 中 ， 所 谓 的 线 程 池 中 的 “ 线 程 ” ， 其 实 是 被 抽 象 为 了 一 个 静 态内 部 类Worker， 它 基 于AQS实 现 ， 存 放 在 线 程 池 的Hash Set&lt; Worker&gt; workers 成 员 变 量 中 ；</p> <p>而 需 要 执 行 的 任 务 则 存 放 在 成 员 变 量work Queue（ Blocking Queue&lt; Runnable&gt; work Queue） 中。这 样 ， 整 个 线 程 池 实 现 的 基 本 思 想 就 是 ： 从work Queue中 不 断 取 出需 要 执 行 的 任 务 ， 放 在 Workers 中 进 行 处 理 。</p></li> <li><p><strong>线程池的三大方法</strong></p> <p>1、Executors.newFixedThreadPool(int)，执行长期任务性能好，创建一个线程池，一池有N个固定的线程，有固定线程数的线程</p> <p>2、Executors.newSingleThreadExecutor()，只有一个线程</p> <p>3、Executors.newCachedThreadPool()，执行很多短期异步任务，线程池根据需要创建新线程，但在先构建的线程可用时将重用他们。可扩容，遇强则强</p></li> <li><p><strong>创建线程池的几个核心构造参数？</strong></p> <p>阿里巴巴开发手册中创建线程池强制使用ThreadPoolExecutor创建线程，主要的参数如下：</p> <p>corePoolSize ：核心线程数。在创建了线程池后，线程中没有任何线程，等到有任务到来时才创建
线程去执行任务。默认情况下，在创建了线程池后，线程池中的线程数为0，当有任务来之后，就会创建
一个线程去执行任务，当线程池中的线程数目达到corePoolSize后，就会把到达的任务放到缓存队列当
中。</p> <p>maximumPoolSize ：最大线程数。表明线程中最多能够创建的线程数量，此值必须大于等于1。</p> <p>keepAliveTime ：空闲的线程保留的时间。</p> <p>TimeUnit ：空闲线程的保留时间单位。</p> <p>BlockingQueue&lt; Runnable&gt; ：阻塞队列，存储等待执行的任务。参数有ArrayBlockingQueue、LinkedBlockingQueue、SynchronousQueue可选。</p> <p>ThreadFactory ：线程工厂，用来创建线程，一般默认即可</p> <p>RejectedExecutionHandler ：队列已满，而且任务量大于最大线程的异常处理策略。有以下取值</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>ThreadPoolExecutor.AbortPolicy:丢弃任务并抛出RejectedExecutionException异常。
ThreadPoolExecutor.DiscardPolicy：也是丢弃任务，但是不抛出异常。
ThreadPoolExecutor.DiscardOldestPolicy：丢弃队列最前面的任务，然后重新尝试执行任务
（重复此过程）
ThreadPoolExecutor.CallerRunsPolicy：由调用线程处理该任务
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div></li> <li><p><strong>请谈谈 ThreadLocal 是怎么解决并发安全的？</strong></p> <p>ThreadLocal 为每一个线程维护变量的副本，把共享数据的可见范围限制在同一个线程之内，其实现原理是，在 ThreadLocal 类中有一个 Map，用于存储每一个线程的变量的副本。</p></li> <li><p><strong>在java中wait和sleep方法的不同？</strong></p> <p>wait是Object类的方法，sleep是Thread类的方法</p> <p>wait会释放锁，sleep不会释放锁</p> <p>wait需要在同步块中使用，sleep不用</p></li></ul> <h2 id="jvm"><a href="#jvm" class="header-anchor">#</a> JVM</h2> <ul><li><p><strong>内存模型以及分区，需要详细到每个区放什么。</strong> （哪些是线程共享的）</p> <p>程序计数器，作用是指示下一条执行的指令，是线程私有的</p> <p>虚拟机栈：是线程私有的，主要是存放局部变量等信息，每个方法执行都会创建一个栈帧，栈帧中包含局部变量表，方法返回值地址，操作数栈、动态链接和一些其他附加属性</p> <p>本地栈：主要为本地方法服务</p> <p>堆：线程共享，存放对象，成员变量，分为新生代和老年代，新生代有eden区和两个survivor区</p> <p>方法区：线程共享，主要存放class字节码信息和运行时常量池。</p></li> <li><p><strong>堆里面的分区：Eden，survival （from+ to），老年代，各自的特点。</strong></p> <p>Eden：新对象被创建时放到Eden区，Eden区内存不够进行Minor GC,将Eden的对象和一个Survivor空间的对象移动到另一个Survivor，所有对象年龄+1，对象年龄大于设置的值，就会进入老年代</p> <p>老年代空间不足会触发fullGC</p></li> <li><p><strong>GC的两种判定方法</strong></p> <ol><li><p>引用计数法 所谓引用计数法就是给每一个对象设置一个引用计数器，每当有一个地方引用这个对象时，就将计数器加一，引用失效时，计数器就减一。当一个对象的引用计数器为零时，说明此对象没有被引用，也就是“死对象”,将会被垃圾回收. 引用计数法有一个缺陷就是无法解决循环引用问题，也就是说当对象A引用对象B，对象B又引用者对象A，那么此时A,B对象的引用计数器都不为零，也就造成无法完成垃圾回收，所以主流的虚拟机都没有采用这种算法。</p></li> <li><p>可达性算法(引用链法) 该算法的思想是：从一个被称为GC Roots的对象开始向下搜索，如果一个对象到GC Roots没有任何引用链相连时，则说明此对象不可用。 在java中可以作为GC Roots的对象有以下几种:</p></li></ol> <ul><li><p>本地方法栈JNI引用的对象</p></li> <li><p>虚拟机栈中引用的对象</p></li> <li><p>方法区类静态属性引用的对象</p></li> <li><p>方法区常量池引用的对象</p></li></ul></li> <li><p><strong>GC收集器有哪些？CMS收集器与G1收集器的特点。</strong></p> <p>并行收集器：串行收集器使用一个单独的线程进行收集，GC时服务有停顿时间
串行收集器：次要回收中使用多线程来执行
CMS收集器是基于“标记—清除”算法实现的，经过多次标记才会被清除
G1从整体来看是基于“标记—整理”算法实现的收集器，从局部（两个Region之间）上来看是基于“复制”算法实现的</p></li> <li><p><strong>Minor GC与Full GC分别在什么时候发生？</strong></p> <p>Minor GC: 发生在新生代上，因为新生代对象存活时间很短，因此 Minor GC 会频繁执行，执行的速度一般也会比较快。</p> <p>Full GC: 发生在老年代上，老年代对象其存活时间长，因此 Full GC 很少执行，执行速度会比 Minor GC 慢很多</p></li> <li><p><strong>类加载的几个过程：</strong></p> <p>Java 类加载需要经历一下 7 个过程：</p> <ol><li>加载
加载是类加载的第一个过程，在这个阶段，将完成一下三件事情：
• 通过一个类的全限定名获取该类的二进制流。
• 将该二进制流中的静态存储结构转化为方法去运行时数据结构。
• 在内存中生成该类的 Class 对象，作为该类的数据访问入口。</li> <li>验证
验证的目的是为了确保 Class 文件的字节流中的信息不回危害到虚拟机.在该阶段主要完成以下四钟验证:
• 文件格式验证：验证字节流是否符合 Class 文件的规范，如主次版本号是否在当前虚拟机范围内，常量池中的常量是否有不被支持的类型.
• 元数据验证:对字节码描述的信息进行语义分析，如这个类是否有父类，是否集成了不被继承的类等。
• 字节码验证：是整个验证过程中最复杂的一个阶段，通过验证数据流和控制流的分析，确定程序语义是否正确，主要针对方法体的验证。如：方法中的类型转换是否正确，跳转指令是否正确等。
• 符号引用验证：这个动作在后面的解析过程中发生，主要是为了确保解析动作能正确执行。</li> <li>准备
准备阶段是为类的静态变量分配内存并将其初始化为默认值，这些内存都将在方法区中进行分配。准备阶段不分配类中的实例变量的内存，实例变量将会在对象实例化时随着对象一起分配在 Java 堆中。
public static int value=123;//在准备阶段value初始值为0 。在初始化阶段才会变为123 。</li> <li>解析
该阶段主要完成符号引用到直接引用的转换动作。解析动作并不一定在初始化动作完成之前，也有可能在初始化之后。</li> <li>初始化
初始化时类加载的最后一步，前面的类加载过程，除了在加载阶段用户应用程序可以通过自定义类加载器参与之外，其余动作完全由
虚拟机主导和控制。到了初始化阶段，才真正开始执行类中定义的 Java 程序代码。</li> <li>使用</li> <li>卸载</li></ol></li> <li><p>类加载器双亲委派模型机制？</p> <p>当一个类收到了类加载请求时，不会自己先去加载这个类，而是将其委派给父类，由父类去加载，如果此时父类不能加载，反馈给子类，由子类去完成类的加载。</p></li> <li><p><strong>什么是类加载器，类加载器有哪些?</strong></p> <p>实现通过类的权限定名获取该类的二进制字节流的代码块叫做类加载器。 主要有一下四种类加载器:</p> <ol><li>启动类加载器(Bootstrap ClassLoader)用来加载java核心类库，无法被java程序直接引用。</li> <li>扩展类加载器(extensions class loader):它用来加载 Java 的扩展库。Java 虚拟机的实现会提供一个扩展库目录。该类加载器在此目录里面查找并加载 Java 类。</li> <li>系统类加载器（system class loader）：它根据 Java 应用的类路径（CLASSPATH）来加载 Java 类。一般来说，Java 应用的类都是由它来完成加载的。可以通过 ClassLoader.getSystemClassLoader()来获取它。</li> <li>用户自定义类加载器，通过继承 java.lang.ClassLoader类的方式实现。</li></ol></li></ul> <h2 id="mysql"><a href="#mysql" class="header-anchor">#</a> Mysql</h2> <ul><li><p><strong>有哪些数据库优化方面的经验?</strong></p> <p>1、不要使用select *</p> <p>2、- like '%xx'</p> <p>3、索引字段不要用函数</p> <p>4、注意最左匹配原则</p> <p>5、用关联查询代替子查询</p></li> <li><p><strong>请简述常用的索引有哪些种类?</strong></p> <p>普通索引</p> <p>唯一索引</p> <p>联合索引</p> <p>全文索引</p> <p>空间索引</p></li> <li><p><strong>以及在mysql数据库中索引的工作机制是什么？</strong></p></li> <li><p>mysql的复制原理以及流程。</p> <p>主要涉及三个线程: binlog 线程、I/O 线程和 SQL 线程。</p> <ul><li><strong>binlog 线程</strong> : 负责将主服务器上的数据更改写入二进制日志中。</li> <li><strong>I/O 线程</strong> : 负责从主服务器上读取二进制日志，并写入从服务器的中继日志中。</li> <li><strong>SQL 线程</strong> : 负责读取中继日志并重放其中的 SQL 语句。</li></ul></li> <li><p>mysql读写分离</p> <p>主服务器处理写操作以及实时性要求比较高的读操作，而从服务器处理读操作。</p> <p>读写分离能提高性能的原因在于:</p> <ul><li>主从服务器负责各自的读和写，极大程度缓解了锁的争用；</li> <li>从服务器可以使用 MyISAM，提升查询性能以及节约系统开销；</li> <li>增加冗余，提高可用性。</li></ul></li> <li><p><strong>mysql中myisam与innodb的区别？</strong> <font color="red">（引擎相关是可以多看看）</font></p> <ul><li><p>InnoDB</p> <ul><li><p>支持外键</p></li> <li><p>支持事务</p></li> <li><p>支持热备份</p></li> <li><p>支持行级锁</p></li> <li><p>默认隔离级别：可重复读</p></li> <li><p>主索引是聚簇索引</p></li> <li><p>崩溃恢复快</p></li></ul></li> <li><p>MyISAM</p> <ul><li><p>不支持外键</p></li> <li><p>不支持事务</p></li> <li><p>不支持行级锁，只支持表锁</p></li> <li><p>崩溃恢复慢</p></li> <li><p>支持压缩表</p></li></ul></li></ul></li> <li><p><strong>MySQL中InnoDB支持的四种事务隔离级别名称，以及逐级之间的区别？</strong></p> <p>mysql会出现四种并发问题分别是脏读，不可重复读，幻影读，丢失修改</p> <p>Read Uncommitted（未提交读） &gt;&gt; 事务未提交其他事务就能读取，导致脏读（Dirty Read）。
Read Committed（提交读） &gt;&gt; 一个事务提交其他事务才能读取到修改，解决了脏读问题，但是无法解决不可重复读问题,即一个事务读取一个数据两次可能得到不同的结果。
Repeatable Read（可重读） &gt;&gt; 这是 MySQL 的默认事务隔离级别，通过多版本并发控制实现,MVVC，它确保同一事务的多个实例在并发读取数据时，会看到同样的数据行。解决了不可重复读问题，但是会导致幻读，InnoDB采用mvvc+间隙锁解决幻读.
Serializable（可串行化） &gt;&gt; 这是最高的隔离级别，事务串行化执行，不会出现并发问题。</p></li> <li><p><strong>HAVNG 子句 和 WHERE的异同点?</strong></p> <p>1.where 分组之前使用，对数据库的数据进行操作，having分组之后使用，对分组后的数据进行操作</p> <p>2.where 后面的条件中不能有聚集函数，比如SUM(),AVG()等，而HAVING可以。</p></li> <li><p><strong>Hash索引和B+树索引有什么区别或者说优劣呢?</strong></p> <p>哈希索引能以 O(1) 时间进行查找，但是失去了有序性，它具有以下限制:</p> <p>Hash索引无法用于排序与分组；</p> <p>Hash索引只支持精确查找，无法用于部分查找和范围查找。</p></li> <li><p><strong>红黑树和B+树索引有什么区别或者说优劣呢?</strong></p></li></ul> <p>红黑树等平衡树也可以用来实现索引，但是文件系统及数据库系统普遍采用 B+ Tree 作为索引结构，主要有以下两个原因:</p> <p>​	(一)更少的查找次数，B+树的高度远小于红黑树</p> <p>​	(二)利用计算机预读特性</p> <p>​	为了减少磁盘 I/O，磁盘往往不是严格按需读取，而是每次都会预读。磁盘每次读取一页，数据库系统将索引的一个节点的大小设置为页的大小，使得一次 I/O 就能完全载入一个节点，并且可以利用预读特性，相邻的节点也能够被预先载入。</p> <ul><li><p><strong>那么在哪些情况下会发生针对该列创建了索引但是在查询的时候并没有使用呢?</strong></p> <div class="language-mysql line-numbers-mode"><pre class="language-text"><code>- like '%xx'
    select * from tb1 where email like '%cn';
当like前缀没有%，后缀有%时，索引有效。 
    
- 使用函数
    select * from tb1 where reverse(email) = 'wupeiqi';
    
    
- or
    select * from tb1 where nid = 1 or name = 'seven@live.com';
    
    
    特别的：当or条件中有未建立索引的列才失效，以下会走索引
            select * from tb1 where nid = 1 or name = 'seven';
            select * from tb1 where nid = 1 or name = 'seven@live.com' and email = 'alex'
            
            
- 类型不一致
    如果列是字符串类型，传入条件是必须用引号引起来，不然...
    select * from tb1 where email = 999;
    
普通索引的不等于不会走索引
- !=
    select * from tb1 where email != 'alex'
    
    特别的：如果是主键，则还是会走索引
        select * from tb1 where nid != 123
- &gt;
    select * from tb1 where email &gt; 'alex'
    
    
    特别的：如果是主键或索引是整数类型，则还是会走索引
        select * from tb1 where nid &gt; 123
        select * from tb1 where num &gt; 123
        
        
#排序条件为索引，则select字段必须也是索引字段，否则无法命中
- order by
    select name from s1 order by email desc;
    当根据索引排序时候，select查询的字段如果不是索引，则不走索引
    select email from s1 order by email desc;
    特别的：如果对主键排序，则还是走索引：
        select * from tb1 order by nid desc;
 
- 组合索引最左前缀
    如果组合索引为：(name,email)
    name and email       -- 使用索引
    name                 -- 使用索引
    email                -- 不使用索引

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br><span class="line-number">34</span><br><span class="line-number">35</span><br><span class="line-number">36</span><br><span class="line-number">37</span><br><span class="line-number">38</span><br><span class="line-number">39</span><br><span class="line-number">40</span><br><span class="line-number">41</span><br><span class="line-number">42</span><br><span class="line-number">43</span><br><span class="line-number">44</span><br><span class="line-number">45</span><br><span class="line-number">46</span><br><span class="line-number">47</span><br><span class="line-number">48</span><br><span class="line-number">49</span><br><span class="line-number">50</span><br></div></div></li> <li><p><strong>说一说三个范式</strong></p> <p>第一范式: 每个列都不可以再拆分.</p> <p>第二范式: 非主键列完全依赖于主键,而不能是依赖于主键的一部分.</p> <p>第三范式: 非主键列直接依赖于主键,不是间接依赖.</p></li> <li><p><strong>MyBatis 怎么实现分页</strong></p> <div class="language- line-numbers-mode"><pre class="language-text"><code>new 一个RowBounds，传入SqlSession.selectlist
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div></li> <li><h6 id="innodb的事务与日志的实现方式"><a href="#innodb的事务与日志的实现方式" class="header-anchor">#</a> <strong>innodb的事务与日志的实现方式</strong></h6> <ol><li>有多少种日志；</li> <li>事物的4种隔离级别</li> <li>事务是如何通过日志来实现的，说得越深入越好。</li> <li><font color="red">事务的传播行为有哪些，常用的是哪几个，A方法调用B方法是否还有事务之类的问题</font></li></ol></li> <li><p><strong>Innodb存储引擎的执行过程：</strong></p> <p>从准备更新一条数据到事务的提交的流程描述</p> <ul><li>首先执行器根据 MySQL 的执行计划来查询数据，先是从缓存池中查询数据，如果没有就会去数据库中查询，如果查询到了就将其放到缓存池中</li> <li>在数据被缓存到缓存池的同时，会写入 undo log 日志文件</li> <li>更新的动作是在 BufferPool 中完成的，同时会将更新后的数据添加到 redo log buffer 中</li> <li>完成以后就可以提交事务，在提交的同时会做以下三件事
<ul><li>将redo log buffer中的数据刷入到 redo log 文件中</li> <li>将本次操作记录写入到 bin log文件中</li> <li>将 bin log 文件名字和更新内容在 bin log 中的位置记录到redo log中，同时在 redo log 最后添加 commit 标记</li></ul></li></ul> <p>至此表示整个更新事务已经完成</p></li> <li><p>事务的ACID与实现原理？</p></li> <li><p><strong>索引的优缺点：</strong></p></li> <li><p><strong>聚簇索引与非聚簇索引</strong>：</p> <p>聚簇索引叶子节点存放的是完整数据，非聚簇索引叶子节点存放的是主键，需要再做一次回表操作。</p></li> <li><p><strong>MySQL主从复制的原理：</strong></p> <p>主要涉及三个线程: binlog 线程、I/O 线程和 SQL 线程。</p> <ul><li><strong>binlog 线程</strong> : 负责将主服务器上的数据更改写入二进制日志中。</li> <li><strong>I/O 线程</strong> : 负责从主服务器上读取二进制日志，并写入从服务器的中继日志中。</li> <li><strong>SQL 线程</strong> : 负责读取中继日志并重放其中的 SQL 语句。</li></ul></li> <li><p><strong>读写分离的好处：</strong></p> <p>主服务器处理写操作以及实时性要求比较高的读操作，而从服务器处理读操作。</p> <p>读写分离能提高性能的原因在于:</p> <ul><li>主从服务器负责各自的读和写，极大程度缓解了锁的争用；</li> <li>从服务器可以使用 MyISAM，提升查询性能以及节约系统开销；</li> <li>增加冗余，提高可用性。</li></ul></li> <li><p><strong>一条SQL执行过程</strong></p> <p><img src="/person-log.io/assets/img/v2-d81711e55342a4c47540cc258ee98f97_720w.d81711e5.jpg" alt="img"></p></li></ul> <h2 id="redis"><a href="#redis" class="header-anchor">#</a> Redis</h2> <ul><li><p><strong>Redis支持哪几种数据类型？</strong></p> <p>String、List、set、Zset、hash</p></li> <li><p>Redis有哪几种数据淘汰策略？</p></li> <li><p><strong>redis一般有哪些使用场景</strong></p> <p>1、热点数据的缓存</p> <p>2、限时业务的运用，如手机验证码，redis中可以使用expire命令设置一个键的生存时间</p> <p>3、计数器相关问题。redis由于incrby命令可以实现原子性的递增，分布式序列号的生成、具体业务还体现在比如限制一个手机号发多少条短信、一个接口一分钟限制多少请求、一个接口一天限制调用多少次等等。</p> <p>4、排行榜相关问题，借助redis的ZSet进行热点数据的排序</p></li> <li><p><strong>为什么要使用它</strong></p></li> <li><p><strong>redis为什么快</strong></p> <p>1、单线程，减少线程之间的竞争，切换</p> <p>2、完全基于内存</p> <p>3、采用了IO多路复用</p></li> <li><p><strong>Redis事务相关的命令有哪几个？</strong>
MULTI、EXEC、DISCARD、WATCH</p></li> <li><p><strong>Redis key的过期时间和永久有效分别怎么设置？</strong>
EXPIRE和PERSIST命令</p></li> <li><p>什么是缓存穿透？如何避免？什么是缓存雪崩？何如避免？什么是缓存击穿？何如避免？</p></li> <li><p><strong>Redis的持久化机制？</strong></p> <p>Redis的持久化机制有RDB和AOF，主要作用是数据备份，即将数据存储在硬盘，保证数据不会因进程退出而丢失。</p></li> <li><p><strong>RDB实现过程</strong></p> <p>RDB是一个对数据库的快照，是一个二进制文件，能通过该文件还原成数据库状态。有两个命令可用于生成RDB文件（SAVE和BGSAVE）。他们之间的区别是：SAVE会<strong>阻塞</strong>Redis服务器进程，直到RDB文件创建完毕为止，阻塞期间，服务器不能处理任何命令请求。而BGSAVE会<strong>fork出一个子进程</strong>，由子进程负责创建RDB文件，<strong>父进程继续处理命令请求</strong>。当子进程完成之后，向父进程<strong>发送信号</strong>。</p></li> <li><p><strong>AOF实现过程</strong></p> <p>AOF持久化是通过保存Redis服务器所执行的写命令来记录数据库状态。服务器启动时，可通过载入和执行AOF文件中保存的命令来还原服务器关闭前的数据库状态。开启AOF持久化后，服务器执行完一个写命令后，会将被执行的写命令追加到服务器状态的aof_buf缓冲区末尾，根据配置文件的<strong>appendfsync</strong>值决定什么时候同步AOF文件。</p></li> <li><p><strong>主从复制过程，作用</strong></p> <p>主从复制可以把主节点的数据复制给从节点。从节点可以备份主节点的数据，起到主节点down调，顶上来接替主节点工作的作用。也可以起到分担主节点读压力的作用。</p> <p>PSYNC有完整重同步和部分重同步的两种模式：</p> <ul><li><p>完全同步</p> <ul><li><p>从服务器向主服务器发送PSYNC命令，主服务器判断运行id和复制偏移量，如果服务器运行id不是主服务器运行id或者复制偏移量不在主服务器的复制积压缓冲区时，执行完全同步操作</p></li> <li><p>主服务器执行BGSAVE，并将新执行的写命令放在一个缓冲区中</p></li> <li><p>主服务器将RDB文件发送给从服务器，从服务器载入</p></li> <li><p>从服务器载入RDB文件后，主服务器缓冲区的写命令发送给从服务器</p></li></ul></li> <li><p>部分同步</p> <ul><li><p>从服务器向主服务器发送PSYNC命令，主服务器判断运行id和复制偏移量，如果服务器运行id为主服务器运行id并且复制偏移量在主服务器的复制积压缓冲区（默认1M）中，执行部分同步操作</p></li> <li><p>根据从服务器发送的复制偏移量，将主服务器的积压缓存区中，在复制偏移量后的写命令发送给从服务器执行</p></li></ul></li></ul></li> <li><p><strong>哨兵机制过程，作用</strong></p> <p>为了实现redis故障转移的自动化。自动发现，自动转移。不需要人工参与。</p></li></ul> <h2 id="spring"><a href="#spring" class="header-anchor">#</a> Spring</h2> <ul><li><p><strong>什么是spring?使用Spring框架的好处是什么？</strong></p> <p>Spring是一个轻量级IOC(控制反转)和AOP（面向切面）的框架，IOC思想能方便我们解耦，AOP能把业务逻辑与系统级服务（日志、异常处理）分离。</p></li> <li><p><strong>Spring的IoC理解：</strong></p> <p>IOC是一种控制反转的思想，就是将对象的创建、注入交给Spring容器，从而实现解耦。他的实现方式是DI，依赖注入。</p></li> <li><p><strong>什么是依赖注入</strong></p> <p>依赖注入是IOC思想的实现方法，由容器动态的将某个依赖关系注入到组件之中</p></li> <li><p><strong>Spring的AOP理解：</strong></p> <p>AOP就是一种面向切面的思想，他把业务逻辑和系统及服务（比如说日志）分离出来，从而实现减少重复代码和动态插拔的效果。</p></li> <li><p><strong>Spring通知（Advice）有哪些类型？</strong></p> <p>前置通知、后置通知、围绕通知、后置返回通知、后置异常通知</p></li> <li><p>spring 单例线程安全问题</p></li> <li><p><strong>Spring中bean的作用域：</strong></p> <p>singleton:唯一 bean 实例</p> <p>prototype:每次请求都会创建一个新的 bean 实例</p> <p>request:每一次HTTP请求都会产生一个新的bean，该bean仅在当前HTTP request内有效</p> <p>session:每一次HTTP请求都会产生一个新的 bean，该bean仅在当前 HTTP session 内有效</p> <p>globalsession:将单个bean定义范围限定为全局HTTP的生命周期<code>Session</code>。</p></li> <li><p>spring bean的生命周期</p> <p><img src="/person-log.io/assets/img/image-20210331095454643.b9fec5d8.png" alt="image-20210331095454643"></p> <p>实例化对象，属性填充，初始化（@PostConstruct）</p></li> <li><p>spring如何创建对象</p></li> <li><p>spring bean创建过程</p></li> <li><p>spring事务的传播机制</p></li> <li><p><strong>Spring框架中的Bean是线程安全的么？如果线程不安全，那么如何处理？</strong></p> <p>如果Spring bean有可变的成员变量，那么他就是线程不安全的，最简单的方式就是将bean的作用域由singleton改为prototype</p></li> <li><p><strong>Spring注入bean的几种方式：</strong></p> <p>通过Autowire注解注入</p> <p>通过构造器注入</p> <p>通过Setter方法注入</p></li> <li><p><strong>Spring的自动装配：</strong></p></li> <li><p>cglib和jdk动态代理区别</p></li> <li><p>Controller全局变量有线程安全问题</p></li> <li><p><strong>Spring事务的实现方式和实现原理：</strong></p> <p>Spring 事务的本质其实就是数据库对事务的支持，没有数据库的事务支持，spring 是无法提供事务功能的。声明式事务@Transactional注解实现事务</p></li> <li><p><strong>Spring事务失效原因</strong></p> <p>没有被Spring管理</p> <p>方法不是Public的</p> <p>数据源没有配置事务</p> <p>捕获了异常</p> <p>异常类型错误</p> <p>自身调用</p></li> <li><p><strong>Spring中的隔离级别：</strong></p> <p>默认</p> <p>未提交读</p> <p>提交读</p> <p>可重复读</p> <p>可串行化</p></li> <li><p><strong>Spring 框架中都用到了哪些设计模式？</strong></p> <p>比如bean，就使用了单例设计模式</p> <p>简单工厂，根据传入一个唯一的标识来获得Bean对象。</p> <p>Spring中的FactoryBean用了工厂方法</p> <p>JdbcTemplate的excute用了模板方法</p></li> <li><p>Spring由哪些模块组成?</p></li> <li><p>BeanFactory – BeanFactory 实现举例。</p></li> <li><p>XMLBeanFactory</p></li> <li><p>解释JDBC抽象和DAO模块。</p></li> <li><p>Spring AOP里面的几个名词的概念：</p></li></ul> <h2 id="spring-mvc"><a href="#spring-mvc" class="header-anchor">#</a> Spring MVC</h2> <ul><li><p><strong>什么是Spring MVC ？简单介绍下你对springMVC的理解?</strong></p> <p>MVC是模型(Model)、视图(View)、控制器(Controller)的简写，MVC主要作用是降低了视图与业务逻辑间的双向偶合。</p></li> <li><p><strong>SpringMVC的流程？</strong></p> <p><img src="picture/249993-20161212142542042-2117679195.jpg" alt="img"></p> <p>1、 用户发送请求至前端控制器DispatcherServlet。</p> <p>2、 DispatcherServlet收到请求调用HandlerMapping处理器映射器。</p> <p>3、 处理器映射器找到具体的处理器(可以根据xml配置、注解进行查找)，生成处理器对象及处理器拦截器(如果有则生成)一并返回给DispatcherServlet。</p> <p>4、 DispatcherServlet调用HandlerAdapter处理器适配器。</p> <p>5、 HandlerAdapter经过适配调用具体的处理器(Controller，也叫后端控制器)。</p> <p>6、 Controller执行完成返回ModelAndView。</p> <p>7、 HandlerAdapter将controller执行结果ModelAndView返回给DispatcherServlet。</p> <p>8、 DispatcherServlet将ModelAndView传给ViewReslover视图解析器。</p> <p>9、 ViewReslover解析后返回具体View。</p> <p>10、DispatcherServlet根据View进行渲染视图（即将模型数据填充至视图中）。</p> <p>11、 DispatcherServlet响应用户。</p></li> <li><p><strong>Springmvc的优点:</strong></p> <p>Spring MVC是一个基于Java的实现了MVC设计模式的请求驱动类型的轻量级Web框架，通过把Model，View，Controller分离，将web层进行职责解耦，把复杂的web应用分成逻辑清晰的几部分，简化开发。</p></li> <li><p>SpringMVC怎么样设定重定向和转发的？</p></li> <li><p><strong>@resource,@qualify,@autowired的区别</strong></p> <p>@Autowired只按照类型注入，如果想按照名称注入，配合@Qualifier使用</p> <p>@Resource默认按照名称注入，可同时指定name和type。</p></li> <li><p><strong>SpringMVC常用的注解有哪些？</strong></p> <p>@RestController:用于Controller之上，相当于@Controller和@ResponeBody；</p> <p>@Controller:用于注解Controller；</p> <p>@RequestMapping：用于处理URL映射，注解在Controller或者方法之上；</p> <p>@RequestParam：用于获取http请求的param参数</p> <p>@RequestBody：获取http请求的Body</p> <p>@PathVariable：获取http请求的path的参数</p></li> <li><p><strong>SpingMvc中的控制器的注解一般用哪个？有没有别的注解可以替代？</strong></p> <p>@RestController:用于Controller之上，相当于@Controller和@ResponeBody；</p> <p>@Controller:用于注解Controller；</p></li></ul> <h2 id="spring-boot"><a href="#spring-boot" class="header-anchor">#</a> spring boot</h2> <ul><li>自动配置的原理</li></ul> <h2 id="mybatis"><a href="#mybatis" class="header-anchor">#</a> Mybatis</h2> <ul><li><p><strong>什么是Mybatis？</strong></p> <p>Mybatis是一个半ORM（对象关系映射）框架，它把数据库连接封装起来，开发者开发时只需要关注如何编写SQL语句，可以严格控制sql执行性能，灵活度高。</p></li> <li><p><strong>Mybaits的优缺点：</strong></p> <p>（1）优点：</p> <p>① 基于SQL语句编程，相当灵活，不会对应用程序或者数据库的现有设计造成任何影响，SQL写在XML里，解除sql与程序代码的耦合，便于统一管理；提供XML标签，支持编写动态SQL语句，并可重用。</p> <p>② 与JDBC相比，减少了50%以上的代码量，消除了JDBC大量冗余的代码，不需要手动开关连接；</p> <p>③ 很好的与各种数据库兼容（因为MyBatis使用JDBC来连接数据库，所以只要JDBC支持的数据库MyBatis都支持）。</p> <p>④ 能够与Spring很好的集成；</p> <p>（2）缺点：</p> <p>① SQL语句的编写工作量较大，尤其当字段多、关联表多时，对开发人员编写SQL语句的功底有一定要求。</p> <p>② SQL语句依赖于数据库，导致数据库移植性差，不能随意更换数据库。</p></li> <li><p><strong>#{}和${}的区别是什么？</strong></p> <ol><li>#{}表示一个占位符，即SQL预编译，可以防止SQL注入问题</li> <li>$ {}是直接将参数拼接到SQL语句，即SQL拼接，可能导致SQL注入</li></ol></li> <li><p><strong>通常一个mapper.xml文件，都会对应一个Dao接口，这个Dao接口的工作原理是什么？Dao接口里的方法，参数不同时，方法能重载吗？</strong></p> <p>Dao接口里的方法，是不能重载的，因为是全限名+方法名的保存和寻找策略。</p></li> <li><p><strong>Mybatis的Xml映射文件中，不同的Xml映射文件，id是否可以重复？</strong></p> <p>不同的 Xml 映射文件，如果配置了 namespace，那么 id 可以重复；如果没有配置 namespace，那么 id 不能重复；</p></li></ul> <h2 id="springcloud"><a href="#springcloud" class="header-anchor">#</a> SpringCloud</h2> <ul><li><p><strong>什么是微服务？</strong></p> <p>微服务是一种架构思想，将一个单一的系统拆成一个个小的模块，模块之间相互独立，相互配合最终实现功能。</p></li> <li><p><strong>微服务之间如何独立通讯的?</strong></p> <p>Spring Cloud通过将服务注册到Consul，然后用声明式调用Feign去调用。</p></li> <li><p><strong>什么是熔断？什么是服务降级？</strong></p> <p>微服务架构一个服务出现问题可能导致依赖他的服务不可用，进而可能导致服务雪崩，所以springcloud有一个熔断器Hystrix可以在一个服务不可用的情况下，可以向调用方返回一个备用响应或快速失败，避免服务雪崩，在一段时间后，熔断器还会自动检测服务是否恢复，通过把一部分请求放行，另一部分请求继续返回快速失败，如果放行那部分请求响应成功，则服务恢复，关闭熔断器。</p></li> <li><p><strong>微服务的优缺点是什么？说下你在项目中碰到的坑。</strong></p> <p>优点就是可以把一个应用拆分成多个服务，服务之间相互独立，达到解耦的效果，不同的服务可以用不同的语言开发，他们之间的通信采用http通信。</p> <p>缺点就是复杂，加大运维成本，数据一致性和服务间的通信比较难处理。</p></li> <li><p><strong>你所知道微服务的技术栈有哪些？</strong></p> <p>网关zuul、熔断器hystrix、服务注册与发现Eurka、consul、声明式调用Feign、负载均衡Ribbon</p></li> <li><p><strong>ribbon和feign区别</strong></p> <p>Feign集成了Ribbon，等于Ribbon+restTemplate</p></li></ul> <h2 id="设计模式"><a href="#设计模式" class="header-anchor">#</a> 设计模式</h2> <ul><li><p><strong>请列举出在JDK中几个常用的设计模式？</strong></p> <p>Runtime用到单例模式</p> <p>IO用到装饰者模式</p> <p>Cloneable用到原型模式</p></li> <li><p>你了解什么设计模式</p> <p>单例模式：确保只有一个类只有一个实例</p> <p>简单工厂：由工厂确定要实例化哪个对象</p> <p>工厂方法：将对象的实例化延迟到子类去实现</p> <p>抽象工厂：提供一个接口，创建一个相关的对象家族</p> <p>原型模式：通过对象实例去创建对象，典型的就是clone</p> <p>适配器模式：让一个类的接口通过适配器转换成另外一种类型的接口</p> <p>装饰器模式：动态的增加功能</p> <p>模板方法：提供一个骨架，将具体步骤的实现延迟到子类</p></li> <li><p><strong>什么是设计模式？你用过什么设计模式</strong></p> <p>设计模式是前人总结出来的一套经过反复验证的，优秀的代码设计经验。</p></li> <li><p><strong>使用工厂模式最主要的好处是什么？在哪里使用？</strong></p> <p>解耦，使用方无需知道类是如何创建的</p></li></ul> <h2 id="计算机网络"><a href="#计算机网络" class="header-anchor">#</a> 计算机网络</h2> <ul><li><p><strong>TCP建立连接的过程。</strong></p> <p>TCP是一个可靠的面向连接的传输协议，TCP建立连接的过程是客户端向服务端发送一个SYN标志位为1的报文，表示要建立连接，服务端收到这个报文，回复SYN和ACK标志位为1的报文，表示自己已经收到，并且想和客户端建立连接，这时候客户端知道服务端能接收自己的请求，也能发送请求，但是服务端还不知道客户端是否能接受到自己的请求，所以这时候客户端需要回复服务端一个ACK标志位为1的报文，表示自己接收到了这个请求，服务端收到后，连接建立。</p> <p><img src="picture/image-20210324152317798.png" alt="image-20210324152317798"></p></li> <li><p><strong>TCP断开连接的过程。</strong></p> <p>TCP断开连接是一个四次挥手的过程，首先客户端向服务端发起一个FIN标志位为1的报文，表示自己要断开连接，服务端收到这个断开连接的请求，但是这时候服务端可能还没准备好，所以服务端先发送一个ACK标志位为1的报文，告诉客户端我收到了你断开连接的请求，待会我准备好了之后会告诉你，然后等准备完毕之后，向客户端发送一个FIN+ACK标志位为1的报文，表示自己已经准备好了，可以断开连接了，客户端收到这个报文之后，返回一个ACK标志位为1的报文告诉客户端自己已经收到他的请求，然后等待2MSL，因为可能客户端最后这个报文丢失，服务端收不到就会重新发送一个FIN报文，所以要等2MSL，然后断开连接。</p> <p><img src="picture/image-20210324152930216.png" alt="image-20210324152930216"></p></li></ul> <h2 id="数据结构和算法"><a href="#数据结构和算法" class="header-anchor">#</a> 数据结构和算法</h2> <ul><li><p><strong>⼆叉树与红黑树是什么</strong></p> <p>二叉树特性特性：</p> <ul><li>左⼦树上所有结点的值均⼩于或等于它的根结点的值。</li> <li>右⼦树上所有结点的值均⼤于或等于它的根结点的值。</li> <li>左、右⼦树也分别为⼆叉排序树。</li></ul> <p>红黑树是⼀种⾃平衡的⼆叉查找树，除了符合⼆叉树的特点之外，还符合以下⼏点：</p> <ul><li>节点是红⾊或⿊⾊。</li> <li>根节点是⿊⾊。</li> <li>每个叶⼦节点都是⿊⾊的空节点（NIL节点）。</li> <li>每个红⾊节点的两个⼦节点都是⿊⾊。(从每个叶⼦到根的所有路径上不能有两个连续的红⾊节点)</li> <li>从任⼀节点到其每个叶⼦的所有路径都包含相同数⽬的⿊⾊节点。</li></ul></li> <li><p><strong>b-tree、b+tree多叉树</strong></p> <p>B树非叶子节点存储数据，B+树只有叶子节点存储数据，B+树可以实现范围查找。</p></li></ul></div> <div class="page-edit"><div class="edit-link"><a href="https://github.com/caizongkai/vuepressDemo/edit/main/docs/md/面试题/面试题全.md" target="_blank" rel="noopener noreferrer">帮助我们改善此页面！</a> <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></div> <!----></div> <!----> </div> <!----></div></div>
    <script src="/person-log.io/assets/js/app.900e0138.js" defer></script><script src="/person-log.io/assets/js/22.eb619a13.js" defer></script>
  </body>
</html>
