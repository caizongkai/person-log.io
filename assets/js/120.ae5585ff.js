(window.webpackJsonp=window.webpackJsonp||[]).push([[120],{351:function(a,s,n){"use strict";n.r(s);var v=n(0),t=Object(v.a)({},(function(){this._self._c;return this._m(0)}),[function(){var a=this,s=a._self._c;return s("div",{staticClass:"content"},[s("h1",{attrs:{id:"jvm"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#jvm"}},[a._v("#")]),a._v(" JVM")]),a._v(" "),s("p",[a._v("1、JVM内存结构，看思维导图")]),a._v(" "),s("p",[a._v("2、垃圾回收基础，看笔记")]),a._v(" "),s("p",[a._v("3、类加载机制，类加载过程(未准备)")]),a._v(" "),s("p",[a._v("加载、验证、解析、准备、初始化")]),a._v(" "),s("p",[a._v("4、双亲委派机制")]),a._v(" "),s("p",[a._v("当一个类收到了类加载请求时，不会自己先去加载这个类，而是将其委派给父类，由父类去加载，如果此时父类不能加载，反馈给子类，由子类去完成类的加载。")]),a._v(" "),s("p",[a._v("5、简述java内存分配与回收策率以及Minor GC和Major GC\n1.对象优先在堆的Eden区分配。\n2.大对象直接进入老年代.\n3.长期存活的对象将直接进入老年代. 当Eden区没有足够的空间进行分配时，虚拟机会执行一次Minor GC.Minor Gc通常发生在新生代的Eden区，在这个区的对象生存期短，往往发生Gc的频率较高，回收速度比较快;Full Gc/Major GC 发生在老年代，一般情况下，触发老年代GC的时候不会触发Major GC,但是通过配置，可以在Full GC之前进行一次Minor GC这样可以加快老年代的回收速度。")]),a._v(" "),s("p",[a._v("6、什么是类加载器，类加载器有哪些？")]),a._v(" "),s("p",[a._v("实现通过类的权限定名获取该类的二进制字节流的代码块叫做类加载器。\n主要有一下四种类加载器：\n• 启动类加载器（Bootstrap ClassLoader）用来加载 Java 核心类库，无法被 Java 程序直接引用。\n• 扩展类加载器（extensions class loader）：它用来加载 Java 的扩展库。Java 虚拟机的实现会提供一个扩展库目录。该类加载器在此目录里面查找并加载 Java 类。\n• 系统类加载器（system class loader）：它根据 Java 应用的类路径（CLASSPATH）来加载 Java 类。一般来说，Java 应用的类都是由它来完成加载的。可以通过 ClassLoader.getSystemClassLoader() 来获取它。\n• 用户自定义类加载器，通过继承 java.lang.ClassLoader 类的方式实现。")])])}],!1,null,null,null);s.default=t.exports}}]);