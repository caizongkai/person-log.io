(window.webpackJsonp=window.webpackJsonp||[]).push([[99],{311:function(t,_,s){"use strict";s.r(_);var v=s(0),a=Object(v.a)({},(function(){this._self._c;return this._m(0)}),[function(){var t=this,_=t._self._c;return _("div",{staticClass:"content"},[_("h1",{attrs:{id:"事件"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#事件"}},[t._v("#")]),t._v(" 事件")]),t._v(" "),_("p",[t._v("Redis服务器是一个"),_("strong",[t._v("事件驱动程序")]),t._v("，主要有两种：")]),t._v(" "),_("ul",[_("li",[t._v("文件事件：Redis服务器通过套接字与客户端连接，文件事件就是服务器对套接字操作的抽象。服务器与客户端通信会产生相应文件事件，服务器通过监听这些事件来完成一系列网络通信操作。")]),t._v(" "),_("li",[t._v("时间事件：Redis服务器有一些需要在给定时间内执行的操作，而时间事件就是对这类定时操作的抽象。")])]),t._v(" "),_("p",[t._v("简单来说，文件事件就是"),_("strong",[t._v("套接字操作相关的事件")]),t._v("；时间事件就是"),_("strong",[t._v("定时操作相关事件")]),t._v("。")]),t._v(" "),_("h2",{attrs:{id:"文件事件"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#文件事件"}},[t._v("#")]),t._v(" "),_("strong",[t._v("文件事件")])]),t._v(" "),_("p",[t._v("Redis基于Reactor模式开发的网络事件处理器，就是文件事件处理器。大致是使用I/O多路复用程序"),_("strong",[t._v("同时监听多个套接字")]),t._v("，根据套接字目前执行的任务为套接字"),_("strong",[t._v("关联不同的事件处理器")]),t._v("；当被监听的套接字准备好"),_("strong",[t._v("应答，读取，写入，关闭")]),t._v("等操作时。与之对应的文件事件就会产生，文件事件处理器就开始发挥作用了，调用事先关联好的事件处理器来处理事件。")]),t._v(" "),_("p",[_("img",{attrs:{src:"picture/image-20210308152145350.png",alt:"image-20210308152145350"}})]),t._v(" "),_("p",[t._v("利用多路复用，虽然以单线程的方式运行，但文件事件处理器实现了高性能的网络通信模型，又能很好的与Redis服务器中其他模块对接，保持了设计的"),_("strong",[t._v("简单性")]),t._v("。")]),t._v(" "),_("h3",{attrs:{id:"文件事件处理器的组成"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#文件事件处理器的组成"}},[t._v("#")]),t._v(" "),_("strong",[t._v("文件事件处理器的组成")])]),t._v(" "),_("p",[t._v("由套接字，I/O多路复用程序，文件事件分派器，事件处理器组成。")]),t._v(" "),_("p",[t._v("I/O多路复用程序负责监听多个套接字，并向文件事件分派器传送那些产生了事件的套接字。I/O多路复用程序总是将所有产生事件的"),_("strong",[t._v("套接字放入到一个队列")]),t._v("中，以有序，同步，"),_("strong",[t._v("一次一个套接字")]),t._v("向文件事件分派器传送的姿态来运行。只有当上一个套接字产生事件被事件处理器执行完了，才会继续传送下一个套接字。")]),t._v(" "),_("p",[_("img",{attrs:{src:"picture/image-20210308152258625.png",alt:"image-20210308152258625"}})]),t._v(" "),_("h3",{attrs:{id:"i-o多路复用的实现"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#i-o多路复用的实现"}},[t._v("#")]),t._v(" "),_("strong",[t._v("I/O多路复用的实现")])]),t._v(" "),_("p",[t._v("Redis为所有多路复用的函数库进行包装，每个多路复用函数库在其中都对应一个单独文件："),_("code",[t._v("ae_select.c")]),t._v(","),_("code",[t._v("ae_epoll.c")]),t._v(","),_("code",[t._v("ae_kqueue.c")]),t._v("。为每个多路复用函数都实现了相同的API，所以多路复用程序的底层实现是可以互换的。Redis在多路复用程序源码中用宏定义了相应规则，使得程序在编译时自动选择系统中性能最高的I/O多路复用函数库。")]),t._v(" "),_("h3",{attrs:{id:""}},[_("a",{staticClass:"header-anchor",attrs:{href:"#"}},[t._v("#")])])])}],!1,null,null,null);_.default=a.exports}}]);