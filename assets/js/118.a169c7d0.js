(window.webpackJsonp=window.webpackJsonp||[]).push([[118],{353:function(t,_,r){"use strict";r.r(_);var v=r(0),a=Object(v.a)({},(function(){this._self._c;return this._m(0)}),[function(){var t=this,_=t._self._c;return _("div",{staticClass:"content"},[_("h1",{attrs:{id:"设计模式"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#设计模式"}},[t._v("#")]),t._v(" 设计模式")]),t._v(" "),_("h2",{attrs:{id:"_24大设计模式和7个原则"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_24大设计模式和7个原则"}},[t._v("#")]),t._v(" 24大设计模式和7个原则")]),t._v(" "),_("h3",{attrs:{id:"_7个原则"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_7个原则"}},[t._v("#")]),t._v(" 7个原则")]),t._v(" "),_("p",[t._v("单一职责原则【SINGLE RESPONSIBILITY PRINCIPLE】: 一个类负责一项职责。")]),t._v(" "),_("p",[t._v("里氏替换原则【LISKOV SUBSTITUTION PRINCIPLE】: 继承与派生的规则。")]),t._v(" "),_("p",[t._v("依赖倒置原则【DEPENDENCE INVERSION PRINCIPLE】: 高层模块不应该依赖低层模块，二者都应该依赖其抽象；抽象不应该依赖细节；细节应该依赖抽象。即针对接口编程，不要针对实现编程。")]),t._v(" "),_("p",[t._v("接口隔离原则【INTERFACE SEGREGATION PRINCIPLE】: 建立单一接口，不要建立庞大臃肿的接口，尽量细化接口，接口中的方法尽量少。")]),t._v(" "),_("p",[t._v("迪米特法则【LOW OF DEMETER】: 低耦合，高内聚。")]),t._v(" "),_("p",[t._v("开闭原则【OPEN CLOSE PRINCIPLE】: 一个软件实体如类、模块和函数应该对扩展开放，对修改关闭。")]),t._v(" "),_("p",[t._v("组合/聚合复用原则【Composition/Aggregation Reuse Principle(CARP) 】: 尽量使用组合和聚合少使用继承的关系来达到复用的原则。")]),t._v(" "),_("p",[t._v("相关文章")]),t._v(" "),_("blockquote",[_("p",[_("strong",[t._v("创建型设计模式")])])]),t._v(" "),_("p",[_("a",{attrs:{href:""}},[t._v("创建型 - 单例模式(Singleton pattern)")])]),t._v(" "),_("ul",[_("li",[t._v("单例模式(Singleton pattern): 确保一个类只有一个实例，并提供该实例的全局访问点, 本文介绍6中常用的实现方式")])]),t._v(" "),_("p",[_("a",{attrs:{href:""}},[t._v("创建型 - 简单工厂(Simple Factory)")])]),t._v(" "),_("ul",[_("li",[t._v("简单工厂(Simple Factory)，它把实例化的操作单独放到一个类中，这个类就成为简单工厂类，让简单工厂类来决定应该用哪个具体子类来实例化，这样做能把客户类和具体子类的实现解耦，客户类不再需要知道有哪些子类以及应当实例化哪个子类")])]),t._v(" "),_("p",[_("a",{attrs:{href:""}},[t._v("创建型 - 工厂方法(Factory Method)")])]),t._v(" "),_("ul",[_("li",[t._v("工厂方法(Factory Method)，它定义了一个创建对象的接口，但由子类决定要实例化哪个类。工厂方法把实例化操作推迟到子类")])]),t._v(" "),_("p",[_("a",{attrs:{href:""}},[t._v("创建型 - 抽象工厂(Abstract Factory)")])]),t._v(" "),_("ul",[_("li",[t._v("抽象工厂(Abstract Factory)，抽象工厂模式创建的是对象家族，也就是很多对象而不是一个对象，并且这些对象是相关的，也就是说必须一起创建出来。而工厂方法模式只是用于创建一个对象，这和抽象工厂模式有很大不同")])]),t._v(" "),_("p",[_("a",{attrs:{href:""}},[t._v("创建型 - 生成器(Builder)")])]),t._v(" "),_("ul",[_("li",[t._v("生成器(Builder)，封装一个对象的构造过程，并允许按步骤构造")])]),t._v(" "),_("p",[_("a",{attrs:{href:""}},[t._v("创建型 - 原型模式(Prototype)")])]),t._v(" "),_("ul",[_("li",[t._v("原型模式(Prototype)，使用原型实例指定要创建对象的类型，通过复制这个原型来创建新对象")])])])}],!1,null,null,null);_.default=a.exports}}]);