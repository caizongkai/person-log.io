(window.webpackJsonp=window.webpackJsonp||[]).push([[119],{352:function(a,t,v){"use strict";v.r(t);var r=v(0),s=Object(r.a)({},(function(){this._self._c;return this._m(0)}),[function(){var a=this,t=a._self._c;return t("div",{staticClass:"content"},[t("h1",{attrs:{id:"java基础"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#java基础"}},[a._v("#")]),a._v(" JAVA基础")]),a._v(" "),t("h2",{attrs:{id:"string"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#string"}},[a._v("#")]),a._v(" String")]),a._v(" "),t("p",[a._v("1、浅谈一下String, StringBuffer，StringBuilder的区别？")]),a._v(" "),t("p",[a._v("String是不可变类，每当我们对String进行操作的时候，总是会创建新的字符串。操作String很耗资源,所以Java提供了两个工具类来操作String - StringBuffer和StringBuilder。")]),a._v(" "),t("p",[a._v("StringBuffer和StringBuilder是可变类，StringBuffer是线程安全的，StringBuilder则不是线程安全的。所以在多线程对同一个字符串操作的时候，我们应该选择用StringBuffer。由于不需要处理多线程的情况，StringBuilder的效率比StringBuffer高。")]),a._v(" "),t("p",[a._v("2、String是不可变的有什么好处？")]),a._v(" "),t("p",[a._v("String是不可变类有以下几个优点")]),a._v(" "),t("ul",[t("li",[t("p",[a._v("缓存hash值，因为String的hash值会经常用到，比如String做HashMap的key,那么String不可变保证hash值不可变，只需要计算一次，提高计算效率")])]),a._v(" "),t("li",[t("p",[a._v("由于String是不可变类，所以在多线程中使用是安全的，我们不需要做任何其他同步操作。")])]),a._v(" "),t("li",[t("p",[a._v("String是不可变的，它的值也不能被改变，所以用来存储数据密码很安全。")])]),a._v(" "),t("li",[t("p",[a._v("String Pool 字符串常量池，一旦字符串String 被创建，下次创建相同的字符串就可以从常量池直接取，也只有当String是不可变才能这样做")])])]),a._v(" "),t("p",[a._v("3、String str = new String(“abc”)  到底创建了几个对象？")]),a._v(" "),t("p",[a._v('1~2，首先String str是定义了一个字符串变量，并未产生对象，=不产生对象，那么只有后面的new String("abc")了。把它拆分成"abc"和new String()，首先在字符串常量池去寻找有没有"abc"这个字符串，没有就创建一个“abc”字符串对象在字符串常量池中，然后new String把这个字符串对象拷贝一份到堆中，返回这个对象的引用。所以一共产生两个对象')]),a._v(" "),t("p",[a._v("4、Java8中字符串常量池到底是在哪里？")]),a._v(" "),t("p",[a._v("总的来说就是，JDK1.7之前，运行时常量池（字符串常量池也在里边）是存放在方法区，此时方法区的实现是永久带。\nJDK1.7字符串常量池被单独从方法区移到堆中，运行时常量池剩下的还在永久带（方法区）\nJDK1.8，永久带更名为元空间（方法区的新的实现），但字符串常量池池还在堆中，运行时常量池在元空间（方法区）。")]),a._v(" "),t("p",[a._v("5、intern（）方法")]),a._v(" "),t("p",[a._v("intern方法可以看成返回常量池中该字符串对象的引用。如果没有该字符串对象就把这个对象（或引用）加到常量池。")]),a._v(" "),t("h2",{attrs:{id:"其他"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#其他"}},[a._v("#")]),a._v(" 其他")]),a._v(" "),t("p",[a._v("6、成员变量与局部变量的区别有那些")]),a._v(" "),t("ul",[t("li",[a._v("从语法形式上，看成员变量是属于类的，而局部变量是在方法中定义的变量或是方法的参数；成员变量可以被 public,private,static 等修饰符所修饰，而局部变量不能被访问控制修饰符及 static 所修饰；但是，成员变量和局部变量都能被 final 所修饰；")]),a._v(" "),t("li",[a._v("从变量在内存中的存储方式来看，成员变量是对象的一部分，而对象存在于堆内存，局部变量存在于栈内存")]),a._v(" "),t("li",[a._v("从变量在内存中的生存时间上看，成员变量是对象的一部分，它随着对象的创建而存在，而局部变量随着方法的调用而自动消失。")]),a._v(" "),t("li",[a._v("成员变量如果没有被赋初值，则会自动以类型的默认值而赋值（一种情况例外被")])]),a._v(" "),t("p",[a._v("7、hashCode 与 equals（重要）\n面试官可能会问你：“你重写过 hashcode 和 equals 么，为什么重写equals时必须重写hashCode方法？”")]),a._v(" "),t("p",[a._v("hashCode（）介绍\nhashCode() 的作用是获取哈希码，也称为散列码；它实际上是返回一个int整数。这个哈希码的作用是确定该对象在哈希表中的索引位置。hashCode() 定义在JDK的Object.java中，这就意味着Java中的任何类都包含有hashCode() 函数。\n散列表存储的是键值对(key-value)，它的特点是：能根据“键”快速的检索出对应的“值”。这其中就利用到了散列码！（可以快速找到所需要的对象）\n为什么要有 hashCode\n我们以“HashSet 如何检查重复”为例子来说明为什么要有 hashCode：\n当你把对象加入 HashSet 时，HashSet 会先计算对象的 hashcode 值来判断对象加入的位置，同时也会与其他已经加入的对象的 hashcode 值作比较，如果没有相符的hashcode，HashSet会假设对象没有重复出现。但是如果发现有相同 hashcode 值的对象，这时会调用 equals（）方法来检查 hashcode 相等的对象是否真的相同。如果两者相同，HashSet 就不会让其加入操作成功。如果不同的话，就会重新散列到其他位置。（摘自我的Java启蒙书《Head first java》第二版）。这样我们就大大减少了 equals 的次数，相应就大大提高了执行速度。\nhashCode（）与equals（）的相关规定")]),a._v(" "),t("ul",[t("li",[a._v("如果两个对象相等，则hashcode一定也是相同的")]),a._v(" "),t("li",[a._v("两个对象相等,对两个对象分别调用equals方法都返回true")]),a._v(" "),t("li",[a._v("两个对象有相同的hashcode值，它们也不一定是相等的")]),a._v(" "),t("li",[a._v("因此，equals 方法被覆盖过，则 hashCode 方法也必须被覆盖")]),a._v(" "),t("li",[a._v("hashCode() 的默认行为是对堆上的对象产生独特值。如果没有重写 hashCode()，则该 class 的两个对象无论如何都不会相等（即使这两个对象指向相同的数据）")])]),a._v(" "),t("h2",{attrs:{id:"异常"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#异常"}},[a._v("#")]),a._v(" 异常")]),a._v(" "),t("p",[a._v("见异常笔记")]),a._v(" "),t("h2",{attrs:{id:"序列化"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#序列化"}},[a._v("#")]),a._v(" 序列化")]),a._v(" "),t("p",[a._v("1、"),t("strong",[a._v("什么是java序列化，如何实现java序列化？")])]),a._v(" "),t("p",[a._v("序列化:将对象流化，实现Serializable接口")]),a._v(" "),t("p",[a._v("2、如何阻止序列号？")]),a._v(" "),t("p",[a._v("Transient关键字。")])])}],!1,null,null,null);t.default=s.exports}}]);