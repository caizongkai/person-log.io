(window.webpackJsonp=window.webpackJsonp||[]).push([[11],{192:function(s,a,t){s.exports=t.p+"assets/img/0635cbe8.d27386b9.png"},193:function(s,a,t){s.exports=t.p+"assets/img/a4248c4b-6c1d-4fb8-a557-86da92d3a294.84167751.jpg"},194:function(s,a,t){s.exports=t.p+"assets/img/902b83ab-8054-4bd2-898f-9a4a0fe52830.f3d4dc8e.jpg"},195:function(s,a,t){s.exports=t.p+"assets/img/e6b733ad-606d-4028-b3e8-83c3a73a3797.c402b461.jpg"},369:function(s,a,t){"use strict";t.r(a);var n=[function(){var s=this,a=s._self._c;return a("div",{staticClass:"content"},[a("h2",{attrs:{id:"垃圾回收基础"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#垃圾回收基础"}},[s._v("#")]),s._v(" 垃圾回收基础")]),s._v(" "),a("h2",{attrs:{id:"判断一个对象是否可被回收"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#判断一个对象是否可被回收"}},[s._v("#")]),s._v(" 判断一个对象是否可被回收")]),s._v(" "),a("h3",{attrs:{id:"_1-引用计数算法"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_1-引用计数算法"}},[s._v("#")]),s._v(" 1. 引用计数算法")]),s._v(" "),a("p",[s._v("给对象添加一个引用计数器，当对象增加一个引用时计数器加 1，引用失效时计数器减 1。引用计数为 0 的对象可被回收。")]),s._v(" "),a("p",[s._v("两个对象出现循环引用的情况下，此时引用计数器永远不为 0，导致无法对它们进行回收。")]),s._v(" "),a("p",[s._v("正因为循环引用的存在，因此 Java 虚拟机不使用引用计数算法。")]),s._v(" "),a("div",{staticClass:"language-java line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-java"}},[a("code",[a("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("public")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("class")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[s._v("ReferenceCountingGC")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("{")]),s._v("\n\n    "),a("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("public")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[s._v("Object")]),s._v(" instance "),a("span",{pre:!0,attrs:{class:"token operator"}},[s._v("=")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("null")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(";")]),s._v("\n\n    "),a("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("public")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("static")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("void")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token function"}},[s._v("main")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),a("span",{pre:!0,attrs:{class:"token class-name"}},[s._v("String")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("[")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("]")]),s._v(" args"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("{")]),s._v("\n        "),a("span",{pre:!0,attrs:{class:"token class-name"}},[s._v("ReferenceCountingGC")]),s._v(" objectA "),a("span",{pre:!0,attrs:{class:"token operator"}},[s._v("=")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("new")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[s._v("ReferenceCountingGC")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(";")]),s._v("\n        "),a("span",{pre:!0,attrs:{class:"token class-name"}},[s._v("ReferenceCountingGC")]),s._v(" objectB "),a("span",{pre:!0,attrs:{class:"token operator"}},[s._v("=")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("new")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[s._v("ReferenceCountingGC")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(";")]),s._v("\n        objectA"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(".")]),s._v("instance "),a("span",{pre:!0,attrs:{class:"token operator"}},[s._v("=")]),s._v(" objectB"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(";")]),s._v("\n        objectB"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(".")]),s._v("instance "),a("span",{pre:!0,attrs:{class:"token operator"}},[s._v("=")]),s._v(" objectA"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(";")]),s._v("\n    "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("}")]),s._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("}")]),s._v("\n      \n")])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br"),a("span",{staticClass:"line-number"},[s._v("2")]),a("br"),a("span",{staticClass:"line-number"},[s._v("3")]),a("br"),a("span",{staticClass:"line-number"},[s._v("4")]),a("br"),a("span",{staticClass:"line-number"},[s._v("5")]),a("br"),a("span",{staticClass:"line-number"},[s._v("6")]),a("br"),a("span",{staticClass:"line-number"},[s._v("7")]),a("br"),a("span",{staticClass:"line-number"},[s._v("8")]),a("br"),a("span",{staticClass:"line-number"},[s._v("9")]),a("br"),a("span",{staticClass:"line-number"},[s._v("10")]),a("br"),a("span",{staticClass:"line-number"},[s._v("11")]),a("br"),a("span",{staticClass:"line-number"},[s._v("12")]),a("br")])]),a("h3",{attrs:{id:"_2-可达性分析算法"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_2-可达性分析算法"}},[s._v("#")]),s._v(" 2. 可达性分析算法")]),s._v(" "),a("p",[s._v("通过 GC Roots 作为起始点进行搜索，能够到达到的对象都是存活的，不可达的对象可被回收。")]),s._v(" "),a("p",[a("img",{attrs:{src:t(192),alt:"image"}})]),s._v(" "),a("p",[s._v("在java中可以作为GC Roots的对象有以下几种:")]),s._v(" "),a("ul",[a("li",[s._v("虚拟机栈中引用的对象")]),s._v(" "),a("li",[s._v("方法区类静态属性引用的对象")]),s._v(" "),a("li",[s._v("方法区常量池引用的对象")]),s._v(" "),a("li",[s._v("本地方法栈JNI引用的对象")])]),s._v(" "),a("p",[s._v("虽然这些算法可以判定一个对象是否能被回收，但是当满足上述条件时，一个对象比不一定会被回收。当一个对象不可达GC Root时，这个对象并不会立马被回收，而是出于一个死缓的阶段，若要被真正的回收需要经历两次标记如果对象在可达性分析中没有与GC Root的引用链，那么此时就会被第一次标记并且进行一次筛选，筛选的条件是是否有必要执行finalize()方法。当对象没有覆盖finalize()方法或者已被虚拟机调用过，那么就认为是没必要的。 如果该对象有必要执行finalize()方法，那么这个对象将会放在一个称为F-Queue的队列中，虚拟机会触发一个Finalize()线程去执行，此线程是低优先级的，并且虚拟机不会承诺一直等待它运行完，这是因为如果finalize()执行缓慢或者发生了死锁，那么就会造成F-Queue队列一直等待，造成了内存回收系统的崩溃。GC对处于F-Queue中的对象进行第二次被标记，这时，该对象将被移除”即将回收”集合，等待回收。")]),s._v(" "),a("h2",{attrs:{id:"垃圾回收算法"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#垃圾回收算法"}},[s._v("#")]),s._v(" 垃圾回收算法")]),s._v(" "),a("h3",{attrs:{id:"_1-标记-清除"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_1-标记-清除"}},[s._v("#")]),s._v(" 1. 标记 - 清除")]),s._v(" "),a("p",[a("img",{attrs:{src:t(193),alt:"image"}})]),s._v(" "),a("p",[s._v("将存活的对象进行标记，然后清理掉未被标记的对象。")]),s._v(" "),a("p",[s._v("不足:")]),s._v(" "),a("ul",[a("li",[s._v("标记和清除过程效率都不高；")]),s._v(" "),a("li",[s._v("会产生大量不连续的内存碎片，导致无法给大对象分配内存。")])]),s._v(" "),a("h3",{attrs:{id:"_2-标记-整理"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_2-标记-整理"}},[s._v("#")]),s._v(" 2. 标记 - 整理")]),s._v(" "),a("p",[a("img",{attrs:{src:t(194),alt:"image"}})]),s._v(" "),a("p",[s._v("让所有存活的对象都向一端移动，然后直接清理掉端边界以外的内存。")]),s._v(" "),a("h3",{attrs:{id:"_3-复制"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_3-复制"}},[s._v("#")]),s._v(" 3.复制")]),s._v(" "),a("p",[a("img",{attrs:{src:t(195),alt:"image"}})]),s._v(" "),a("p",[s._v("将内存划分为大小相等的两块，每次只使用其中一块，当这一块内存用完了就将还存活的对象复制到另一块上面，然后再把使用过的内存空间进行一次清理。")]),s._v(" "),a("p",[s._v("主要不足是只使用了内存的一半。")]),s._v(" "),a("p",[s._v("现在的商业虚拟机都采用这种收集算法来回收新生代，但是并不是将新生代划分为大小相等的两块，而是分为一块较大的 Eden 空间和两块较小的 Survivor 空间，每次使用 Eden 空间和其中一块 Survivor。在回收时，将 Eden 和 Survivor 中还存活着的对象一次性复制到另一块 Survivor 空间上，最后清理 Eden 和使用过的那一块 Survivor。")]),s._v(" "),a("h3",{attrs:{id:"_4-分代收集"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_4-分代收集"}},[s._v("#")]),s._v(" 4. 分代收集")]),s._v(" "),a("p",[s._v("现在的商业虚拟机采用分代收集算法，它根据对象存活周期将内存划分为几块，不同块采用适当的收集算法。")]),s._v(" "),a("p",[s._v("一般将堆分为新生代和老年代。")]),s._v(" "),a("ul",[a("li",[s._v("新生代使用: 复制算法")]),s._v(" "),a("li",[s._v("老年代使用: 标记 - 清除 或者 标记 - 整理 算法")])])])}],e=t(0),r=Object(e.a)({},(function(){this._self._c;return this._m(0)}),n,!1,null,null,null);a.default=r.exports}}]);