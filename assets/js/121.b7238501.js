(window.webpackJsonp=window.webpackJsonp||[]).push([[121],{350:function(n,e,v){"use strict";v.r(e);var a=v(0),r=Object(a.a)({},(function(){this._self._c;return this._m(0)}),[function(){var n=this,e=n._self._c;return e("div",{staticClass:"content"},[e("p",[n._v("1、mysql中varchar与char的区别以及varchar(50)中的50代表的涵义？\n1.varchar与char的区别: char是一种固定长度的类型，varchar则是一种可变长度的类型.\n2.varchar(50)中50的涵义 : 最多存放50个字节\n3.int（20）中20的涵义: int(M)中的M indicates the maximum display width (最大显示宽度)for integer types. The maximum legal display width is 255.")]),n._v(" "),e("p",[n._v("2、MySQL中InnoDB引擎的行锁是通过加在什么上完成（或称实现）的？\nInnoDB行锁是通过给索引上的索引项加锁来实现的，这一点MySQL与Oracle不同，后者是通过在数据块中对相应数据行加锁来实现的。InnoDB这种行锁实现特点意味着：只有通过索引条件检索数据，InnoDB才使用行级锁，否则，InnoDB将使用表锁！")]),n._v(" "),e("p",[n._v("3、Mysql主从复制")]),n._v(" "),e("p",[n._v("4、[SELECT *] 和[SELECT 全部字段]的2种写法有何优缺点?")]),n._v(" "),e("p",[n._v("1，数据库需要知道 * 等于什么 = 查数据字典会增大开销（记录数据库和应用程序元数据的目录）\n2，多出一些不用的列，这些列可能正好不在索引的范围之内（索引的好处不多说）select * 杜绝了索引覆盖的可能性，而索引覆盖又是速度极快，效率极高，业界极为推荐的查询方式。\n3，不需要的字段会增加数据传输的时间，即使 mysql 服务器和客户端是在同一台机器上，使用的协议还是 tcp，通信也是需要额外的时间。\n4，大字段，例如很长的 varchar，blob，text。准确来说，长度超过 728 字节的时候，会把超出的数据放到另外一个地方，因此读取这条记录会增加一次 io 操作。----mysql innodb")]),n._v(" "),e("p",[e("strong",[n._v("5、HAVNG 子句 和 WHERE的异同点?")]),n._v("\n1.语法上：where 用表中列名，having用select结果别名\n2.影响结果范围：where从表读出数据的行数，having返回客户端的行数\n3.索引：where 可以使用索引，having不能使用索引，只能在临时结果集操作\n4.where后面不能使用聚集函数，having是专门使用聚集函数的。")]),n._v(" "),e("p",[n._v("6、Mysql常见优化")]),n._v(" "),e("ul",[e("li",[n._v("不要用select *")]),n._v(" "),e("li",[n._v("建索引")]),n._v(" "),e("li",[n._v("避免索引覆盖不到的情况：比如说%xxx,以及不符合最左匹配原则（联合索引遇到between会停止），不要对索引使用函数，类型一致")]),n._v(" "),e("li",[n._v("order by 索引（要符合最左匹配的顺序）")])])])}],!1,null,null,null);e.default=r.exports}}]);